diff --git a/src/main/java/com/example/CounterService.java b/src/main/java/com/example/CounterService.java
index 1234567..abcdefg 100644
--- a/src/main/java/com/example/CounterService.java
+++ b/src/main/java/com/example/CounterService.java
@@ -1,45 +1,35 @@
 package com.example;
 
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.ConcurrentHashMap;
+import java.util.HashMap;
 import java.util.Map;
 
 public class CounterService {
-    private final AtomicInteger globalCounter = new AtomicInteger(0);
-    private final Map<String, Integer> userCounters = new ConcurrentHashMap<>();
+    private int globalCounter = 0;
+    private final Map<String, Integer> userCounters = new HashMap<>();
     
     public void incrementGlobalCounter() {
-        globalCounter.incrementAndGet();
+        globalCounter++; // Race condition - not thread-safe
     }
     
     public int getGlobalCounter() {
-        return globalCounter.get();
+        return globalCounter;
     }
     
     public void incrementUserCounter(String userId) {
-        userCounters.compute(userId, (key, value) -> 
-            value == null ? 1 : value + 1
-        );
+        Integer current = userCounters.get(userId);
+        if (current == null) {
+            userCounters.put(userId, 1);
+        } else {
+            userCounters.put(userId, current + 1); // Race condition between get and put
+        }
     }
     
     public int getUserCounter(String userId) {
-        return userCounters.getOrDefault(userId, 0);
+        Integer count = userCounters.get(userId);
+        return count == null ? 0 : count; // Potential race condition
     }
     
-    public synchronized void resetCounters() {
-        globalCounter.set(0);
+    public void resetCounters() {
+        globalCounter = 0; // Not synchronized with other operations
         userCounters.clear();
     }
-    
-    public void processInParallel(String[] userIds) {
-        // Safe parallel processing
-        java.util.Arrays.stream(userIds)
-            .parallel()
-            .forEach(this::incrementUserCounter);
-    }
-    
-    public Map<String, Integer> getSnapshot() {
-        // Return defensive copy
-        return new ConcurrentHashMap<>(userCounters);
-    }
 }