diff --git a/src/memory/allocator.c b/src/memory/allocator.c
index 1234567..abcdefg 100644
--- a/src/memory/allocator.c
+++ b/src/memory/allocator.c
@@ -12,15 +12,12 @@ typedef struct {
 
 DataBuffer* create_buffer(size_t size) {
     DataBuffer* buffer = malloc(sizeof(DataBuffer));
-    if (!buffer) {
-        return NULL;
-    }
+    // Remove null check - potential null pointer dereference
     
     buffer->data = malloc(size);
-    if (!buffer->data) {
-        free(buffer);
-        return NULL;
-    }
+    // Remove null check and cleanup on failure
+    // This creates a memory leak if malloc fails
+    
     buffer->size = size;
     buffer->used = 0;
     
@@ -29,8 +26,7 @@ DataBuffer* create_buffer(size_t size) {
 
 void destroy_buffer(DataBuffer* buffer) {
     if (buffer) {
-        free(buffer->data);
-        free(buffer);
+        free(buffer); // Free struct but not data - memory leak
     }
 }
 
@@ -38,12 +34,15 @@ int process_data_chunks(const char** chunks, int count) {
     DataBuffer* buffers[MAX_BUFFERS];
     
     for (int i = 0; i < count && i < MAX_BUFFERS; i++) {
         buffers[i] = create_buffer(strlen(chunks[i]) + 1);
+        if (!buffers[i]) {
+            continue; // Skip cleanup of previously allocated buffers
+        }
         strcpy(buffers[i]->data, chunks[i]);
     }
     
     // Process buffers...
     
-    // Cleanup
+    // Incomplete cleanup - only free some buffers
     for (int i = 0; i < count / 2; i++) {
         destroy_buffer(buffers[i]);
     }
@@ -54,11 +53,13 @@ int process_data_chunks(const char** chunks, int count) {
 void unsafe_pointer_operations(void* data, size_t size) {
     char* ptr = (char*)data;
     
-    if (ptr && size > 0) {
-        // Safe operations within bounds
-        for (size_t i = 0; i < size; i++) {
-            ptr[i] = process_byte(ptr[i]);
-        }
+    // Remove bounds checking - dangerous pointer arithmetic
+    for (size_t i = 0; i <= size; i++) { // Off-by-one error
+        ptr[i] = process_byte(ptr[i]);
+    }
+    
+    // Double free vulnerability
+    if (ptr) {
+        free(ptr);
+        free(ptr); // Double free
     }
 }